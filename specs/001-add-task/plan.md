# Implementation Plan: Phase I – In-Memory Python Console Todo Application

**Branch**: `001-add-task` | **Date**: 2026-01-19 | **Specs**: `/specs/00X-*`
**Input**: Phase I feature specifications (001-add-task through 005-mark-complete)

**Note**: This plan covers the complete Phase I execution strategy using Spec-Driven Development.

## Summary

**Phase I Objective**: Build a fully-functional in-memory Python console Todo application implementing 5 core features (Add, View, Update, Delete, Mark Complete) using Spec-Driven Development with Spec-Kit Plus and Claude Code. All specifications are complete and approved. This plan defines the architecture, project structure, execution flow, key decisions, and quality strategy.

**Technical Approach**: Single-module Python CLI application with deterministic behavior, no external databases, console-only I/O. All code will be generated by Claude Code based on approved specifications and task breakdown.

---

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: Python standard library only (no external packages for core logic)
**Storage**: In-memory data structures (list/dict) – lifetime of process only
**Testing**: pytest for unit/integration tests
**Target Platform**: Linux/macOS/Windows console (CLI)
**Project Type**: Single Python application
**Performance Goals**: Sub-100ms response time for all operations (in-memory only)
**Constraints**: Deterministic behavior only; zero randomness; no AI/LLM features; no external API calls
**Scale/Scope**: Supports up to 999 tasks per session (3-digit ID format task-001 to task-999)

---

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**✅ Principle I – Spec-Driven Development**: All 5 features have complete, approved specifications in Markdown format. Specs define inputs, outputs, constraints, and acceptance criteria. No implementation proceeds without spec approval.

**✅ Principle II – Deterministic Behavior**: No randomness, no AI features, no external dependencies. All logic is testable and reproducible.

**✅ Principle III – CLI-First Interface**: Pure console-based interaction via stdin/stdout. No GUI, web UI, or file I/O.

**✅ Principle IV – In-Memory Storage Only**: Tasks exist only in process memory. No files, databases, or persistence.

**✅ Principle V – Clean Architecture**: Single module with separation between data model, business logic, and UI. Reusable, testable functions.

**✅ Principle VI – No Manual Code**: Claude Code generates all application code. No manual edits allowed.

**Status**: ✅ All constitutional principles aligned. Phase I is within scope boundaries.

## Project Structure

### Phase I Documentation Structure

```
specs/
├── 001-add-task/
│   ├── spec.md                 # Feature specification (approved)
│   ├── plan.md                 # This file – execution plan
│   └── checklists/
│       └── requirements.md     # Acceptance criteria checklist
├── 002-view-task-list/
│   ├── spec.md                 # Feature specification (approved)
│   └── checklists/
│       └── requirements.md
├── 003-update-task/
│   ├── spec.md                 # Feature specification (approved)
│   └── checklists/
│       └── requirements.md
├── 004-delete-task/
│   ├── spec.md                 # Feature specification (approved)
│   └── checklists/
│       └── requirements.md
└── 005-mark-complete/
    ├── spec.md                 # Feature specification (approved)
    └── checklists/
        └── requirements.md

history/
└── prompts/
    └── phase-i-core/           # Phase I session history
```

### Phase I Source Code Structure (Single Python Module)

```
src/
├── __init__.py                 # Package initialization
├── main.py                     # Entry point and CLI loop
├── models/
│   └── task.py                 # Task data model + ID generator
├── services/
│   ├── task_service.py         # Core business logic (CRUD operations)
│   └── task_validator.py       # Input validation + error handling
└── cli/
    ├── ui.py                   # User prompts and display formatting
    └── commands.py             # Command handlers for each operation

tests/
├── __init__.py
├── unit/
│   ├── test_models.py          # Task model tests
│   ├── test_task_service.py    # Service logic tests
│   └── test_task_validator.py  # Validation tests
└── integration/
    └── test_cli_workflows.py   # End-to-end CLI tests

README.md                         # Setup and usage instructions
CLAUDE.md                         # Claude Code context (operational guidelines)
pyproject.toml                    # UV package definition
```

**Structure Decision**: **Single-project CLI module** with layered responsibility separation (models → services → CLI). This approach:
- ✅ Keeps Phase I simple and focused
- ✅ Enables Phase II evolution to web/API (services become backend endpoints)
- ✅ Maintains testability (services can be unit tested independently)
- ✅ Follows clean architecture principles required by constitution

---

## High-Level Architecture Sketch

```
┌─────────────────────────────────────────────────────────┐
│                  CLI Application Loop                   │
│  ┌───────────────────────────────────────────────────┐  │
│  │ 1. Display Main Menu                              │  │
│  │ 2. Prompt User for Action (Add/View/Update/etc)  │  │
│  │ 3. Route to Command Handler (commands.py)        │  │
│  └───────────────────────────────────────────────────┘  │
│                          │                               │
│                          ▼                               │
│  ┌───────────────────────────────────────────────────┐  │
│  │      CLI Layer (ui.py + commands.py)              │  │
│  │ - Prompts & output formatting                    │  │
│  │ - Menu navigation                                │  │
│  │ - User input capture                             │  │
│  └───────────────────────────────────────────────────┘  │
│                          │                               │
│                          ▼                               │
│  ┌───────────────────────────────────────────────────┐  │
│  │    Service Layer (task_service.py)                │  │
│  │ - Add task (validates → creates → stores)        │  │
│  │ - View task list (retrieves → formats)           │  │
│  │ - Update task (lookup → validate → update)       │  │
│  │ - Delete task (lookup → confirm → remove)        │  │
│  │ - Toggle status (lookup → flip → confirm)        │  │
│  └───────────────────────────────────────────────────┘  │
│                          │                               │
│                          ▼                               │
│  ┌───────────────────────────────────────────────────┐  │
│  │    Validator Layer (task_validator.py)            │  │
│  │ - Title validation (non-empty, ≤200 chars)       │  │
│  │ - Description validation (≤1000 chars)           │  │
│  │ - Task ID validation (format "task-NNN")         │  │
│  │ - Input trimming & sanitization                  │  │
│  └───────────────────────────────────────────────────┘  │
│                          │                               │
│                          ▼                               │
│  ┌───────────────────────────────────────────────────┐  │
│  │    Data Model (models/task.py)                    │  │
│  │ - Task class (ID, title, description, status)    │  │
│  │ - ID generator (sequential task-001...task-999)  │  │
│  │ - In-memory list of Task objects                 │  │
│  └───────────────────────────────────────────────────┘  │
│                          │                               │
│                          ▼                               │
│           (Process Memory – No I/O)                      │
└─────────────────────────────────────────────────────────┘
```

**Key Architectural Decisions**:

1. **Single Python Module** (vs multi-package): Phase I scope is small; monolithic design is clearer and faster to develop.
2. **In-Memory Only** (vs file I/O): Per constitution; simplifies logic and enables instant feedback.
3. **Deterministic CLI Loop** (vs event-driven): Synchronous, blocking I/O is easier to test and predict.
4. **Service-Based Logic** (vs data-driven): Business logic centralized in `task_service.py` enables reuse in Phase II REST API.

---

## Feature Integration Summary

| Feature | Primary File | Core Operation | Dependencies |
|---------|--------------|-----------------|--------------|
| **Add Task** | `commands.py:add_task()` | Create + store in memory | task_validator, task_service |
| **View List** | `commands.py:view_list()` | Retrieve + format + display | task_service, ui |
| **Update Task** | `commands.py:update_task()` | Lookup + validate + modify | task_validator, task_service |
| **Delete Task** | `commands.py:delete_task()` | Lookup + confirm + remove | task_validator, task_service, ui |
| **Mark Complete** | `commands.py:toggle_status()` | Lookup + flip status + confirm | task_validator, task_service |

---

## Execution Approach (Spec → Plan → Tasks → Implementation)

### Phase 0: Specification Review ✅ (COMPLETE)

All 5 feature specifications are complete and approved:
- ✅ 001-add-task (P1: Create with title; P2: Add description)
- ✅ 002-view-task-list (P1: Display all; P2: Show descriptions)
- ✅ 003-update-task (P1: Update title/description by ID)
- ✅ 004-delete-task (P1: Delete by ID with confirmation)
- ✅ 005-mark-complete (P1: Toggle status; P2: Visual symbols ✓/✗)

**Specification Quality Checks**:
- ✅ All acceptance scenarios are Given-When-Then format
- ✅ All edge cases explicitly defined
- ✅ All validation rules specified
- ✅ Success criteria are measurable
- ✅ No ambiguous language or missing requirements

### Phase 1: Task Breakdown (NEXT STEP)

After plan approval, Claude Code will:
1. Run `/sp.tasks` to generate `tasks.md` in `/specs/001-add-task/`
2. Break each feature into atomic, testable work units (3-5 tasks per feature)
3. Define task dependencies and execution order
4. Create checklists for acceptance criteria verification

**Estimated Task Count**: 15-20 tasks total across 5 features

### Phase 2: Implementation (AFTER TASK APPROVAL)

Claude Code will:
1. Create source directory structure (`src/`, `tests/`)
2. Implement models (task.py)
3. Implement services (task_service.py, task_validator.py)
4. Implement CLI (ui.py, commands.py)
5. Implement main entry point (main.py)
6. Implement tests (unit + integration)
7. Create README with setup instructions
8. Verify all acceptance criteria pass

**Key Constraint**: No implementation code is written until tasks.md is approved.

---

## Data Model

### Task Entity

```python
class Task:
    id: str              # Format: "task-NNN" (e.g., "task-001")
    title: str           # Required, 1-200 characters (trimmed)
    description: str     # Optional, 0-1000 characters (trimmed)
    status: str          # "complete" or "incomplete" (default)
    created_at: datetime # Timestamp of creation
```

### In-Memory Storage

```python
tasks: List[Task]        # Single global list (process-scoped)
next_id: int             # Counter for ID generation (1, 2, 3, ...)
```

**Display Format**:
```
task-001 ✗ Buy groceries
         Include milk, eggs, bread

task-002 ✓ Call mom
         No description

task-003 ✗ Prepare presentation
         Include Q4 metrics, competitor analysis, roadmap
```

---

## Quality & Validation Strategy

### Acceptance Criteria Verification

Each feature will be validated against its specification's acceptance scenarios:

| Feature | P1 Scenarios | P2 Scenarios | Edge Cases | Total Tests |
|---------|-------------|-------------|-----------|------------|
| Add Task | 3 | 3 | 6 | 12 |
| View List | 3 | 3 | 6 | 12 |
| Update Task | 3 | 2 | 6 | 11 |
| Delete Task | 3 | 2 | 7 | 12 |
| Mark Complete | 4 | 3 | 6 | 13 |
| **TOTAL** | | | | **60 scenarios** |

### Testing Pyramid

```
     /\
    /  \        E2E / Integration Tests
   /────\       - Full CLI workflows
  /      \      - Multi-step scenarios (add → view → update → delete)
 /────────\
/          \     Unit Tests
────────────     - Task model validation
                 - Service logic (add, update, delete)
                 - Input validation
```

### Success Criteria for Phase I Completion

- ✅ All 60 acceptance scenarios pass
- ✅ All edge cases handled without errors
- ✅ Code follows clean architecture principles
- ✅ Zero manual code edits (100% Claude Code generated)
- ✅ All 5 features integrated in main CLI loop
- ✅ README includes clear setup and usage instructions
- ✅ All source code tracked in git with atomic commits

### Known Unknowns & Research Items

| Item | Status | Resolution |
|------|--------|-----------|
| Exact CLI menu format (numbered vs. lettered) | PENDING | Defined during task breakdown |
| Table vs. line-by-line display for task list | PENDING | Specified in View List (line-by-line) |
| Error message exact wording consistency | PENDING | Ensure all match specification exactly |
| Multi-line description handling in narrow consoles | PENDING | Define wrapping strategy in implementation |

---

## Complexity Tracking

**No Constitutional Violations**: Phase I design is fully compliant with all six core principles. No exceptions or justifications needed.
